{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#ergate","title":"Ergate","text":""},{"location":"#about","title":"About","text":"<p>Ergate is a fully-typed framework upon which you can build distributed workers to process any given set of steps in a pre-defined order. Instead of restricting your choices to a given set of queues or state stores, Ergate simply defines a common set of functions that your queue and state store handlers must implement, leaving the implementation up to you.</p>"},{"location":"#installation","title":"Installation","text":"<p>Ergate is available on PyPi, and therefore all you need to do to use it is <code>pip install</code> it: <pre><code>pip install ergate\n</code></pre></p>"},{"location":"#example","title":"Example","text":"<p>In this example, we're using a simple Python queue and triggering a Job manually just before running the app. However, the queue and state store implementations are completely up to you as long as they implement the methods shown here.</p> <pre><code>from queue import Queue\nfrom ergate import Ergate, Job, Workflow\n\n\nqueue: Queue[Job] = Queue()\n\n\nclass MyQueue:\n    def get_one(self) -&gt; Job:\n        return queue.get()\n\n    def put(self, job: Job) -&gt; None:\n        queue.put(job)\n\n\nclass MyStateStore:\n    def update(self, job: Job) -&gt; None:\n        print(f\"Updating {job.id}\")\n\n\nworkflow = Workflow(unique_name=\"my_first_workflow\")\n\n@workflow.step\ndef say_hi() -&gt; None:\n    print(\"Hello world\")\n\n\n@workflow.step\ndef say_bye() -&gt; None:\n    print(\"Goodbye world\")\n\n\napp = Ergate(queue=MyQueue(), job_state_store=MyStateStore())\napp.register_workflow(workflow)\n\n\nif __name__ == \"__main__\":\n    queue.put(Job(id=1, workflow_name=\"my_first_workflow\"))\n    app.run()\n</code></pre>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<ul> <li>Ziply Fiber: For giving me the initial idea to create this project and allowing me to turn it into a personal, open-source project.</li> <li>FastAPI: For inspiring me on the implementation of a bunch of the features supported by Ergate (such as the use of <code>Depends</code> for argument injection or the app's <code>lifespan</code> argument).</li> <li>Sanic: For getting me originally into the open-source world and for their use of unique names in blueprints (similar to workflows in Ergate).</li> </ul>"},{"location":"basics/","title":"Tutorial - user guide","text":"<p>This section will guide you step by step through all of the basic concepts of Ergate. You should read through each of the sections in the order that they're displayed in, as they build on top of each other.</p> <p>Throughout the tutorial, you will encounter different codeblocks; all of which have a header displaying a filename. There are some expectations for you to be able to follow along:</p> <ul> <li>If it is the first time you encounter a file, create it locally and copy the contents of the codeblock into it.</li> <li>If you've encountered a file previously, modify it to match the contents of the latest codeblock.</li> </ul> <p>At the end of some sections you will find a simple challenge. These challenges are meant to help you understand the concepts you've just learned. Remember to check out the solution once you're done, and update your code accordingly.</p>"},{"location":"basics/creating-a-workflow/","title":"Creating a workflow","text":"<p>Workflows are a set of predefined steps that are aimed towards completing a specific task. They are identified by a constant, unique name.</p> <p>Workflow steps are created by using the <code>step</code> decorator on a workflow object. Steps are executed sequentially.</p>"},{"location":"basics/creating-a-workflow/#defining-a-workflow","title":"Defining a workflow","text":"<p>Defining a workflow is extremely simple. All you have to do it import the class, create an object with a unique name and assign steps to it. Here's an example:</p> my_workflow.py<pre><code>from ergate import Workflow\n\nworkflow = Workflow(unique_name=\"my_first_workflow\")\n\n@workflow.step\ndef step_1() -&gt; None:\n    print(\"Hello, I am step 1\")\n\n@workflow.step\ndef step_2() -&gt; None:\n    print(\"Hello, I am step 2\")\n</code></pre>"},{"location":"basics/creating-a-workflow/#registering-a-workflow","title":"Registering a workflow","text":"<p>Once you've defined a workflow, you need to let your Ergate application know that it exists. To do so, simply call the <code>register_workflow</code> method in your app instance with the workflow object you've created.</p> <p>Note</p> <p>Running this will make the app appear \"stuck\". The reason for this is that there's no jobs in the queue. We'll cover that in the next section.</p> app.py<pre><code>from ergate import Ergate\nfrom my_queue import MyQueue\nfrom my_state_store import MyStateStore\nfrom my_workflow import workflow\n\napp = Ergate(\n    queue=MyQueue(),\n    state_store=MyStateStore(),\n)\napp.register_workflow(workflow)\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"basics/creating-an-app/","title":"Creating an app","text":"<p>Creating an Ergate application is simple, but you must first create our own queue and state store implementations for Ergate to be able to receive and process jobs.</p> <p>Warning</p> <p>You are responsible for handling any exceptions within your queue and state store implementations. Ergate will not handle any exceptions that occur within these classes, and they will crash your application.</p>"},{"location":"basics/creating-an-app/#implementing-the-queue","title":"Implementing the queue","text":"<p>Ergate requires queue implementations to implement two methods: <code>get_one</code> and <code>put</code>.</p> <ul> <li> <p>The <code>get_one</code> method should fetch data from your queue and return a <code>Job</code> instance. If no job data is found instantly in the queue, this method should block until it is available, at which point it will return a <code>Job</code>.</p> </li> <li> <p>The <code>put</code> method takes a <code>Job</code> model and should put its data back into the queue. This method is called after each step is completed if the job hasn't reached a final state, so that other workers can pick up the data and continue processing the next step in the job.</p> </li> </ul> <p>Let's create a simple queue implementation using Python's built-in <code>Queue</code> class. In this example, our queue will expect JSON data to be submitted through it.</p> my_queue.py<pre><code>from queue import Queue\nfrom ergate import Job\n\nqueue = Queue() # (1)!\n\nclass MyQueue:\n    def get_one(self) -&gt; Job:\n        serialized_job = queue.get()\n        return Job(**serialized_job)\n\n    def put(self, job: Job) -&gt; None:\n        serialized_job = job.model_dump(mode=\"json\")\n        queue.put(serialized_job)\n</code></pre> <ol> <li>In practice, you would likely use a distributed queue implementation, such as Kafka or RabbitMQ.</li> </ol>"},{"location":"basics/creating-an-app/#implementing-the-state-store","title":"Implementing the state store","text":"<p>Ergate requires state store implementations to implement one method: <code>update</code>.</p> <ul> <li>The <code>update</code> method takes a <code>Job</code> model and should update the state of the job in your state store. It is called just before a step is executed and after a step execution is completed.</li> </ul> <p>Let's create a simple state store implementation in which we'll be sending a <code>PATCH</code> request to an API endpoint with the new job's state.</p> my_state_store.py<pre><code>import requests\nfrom ergate import Job\n\nclass MyStateStore:\n    def update(self, job: Job) -&gt; None:\n        requests.patch(\"https://example.com\", json=job.model_dump(mode=\"json\"))\n</code></pre>"},{"location":"basics/creating-an-app/#connecting-everything-together","title":"Connecting everything together","text":"<p>Now that we have our queue and state store implementations, we can finally create the application itself. Simply create an <code>Ergate</code> instance and pass in the queue and state store implementations that you created before.</p> <p>To run it, simply call the <code>run</code> method on the app instance. This will start the application and begin processing jobs.</p> <p>Note</p> <p>Running this will make the app appear \"stuck\". The reason for this is that there's no jobs in the queue. However, it would be pointless to have any, as we have not defined any workflows yet. We'll cover that in the next section.</p> app.py<pre><code>from ergate import Ergate\nfrom my_queue import MyQueue\nfrom my_state_store import MyStateStore\n\napp = Ergate(\n    queue=MyQueue(),\n    state_store=MyStateStore(),\n)\n\nif __name__ == \"__main__\":\n    app.run()\n</code></pre>"},{"location":"basics/dependencies/","title":"Dependencies","text":"<p>Ergate has a very similar dependency injection system to FastAPI, which is designed to be very simple to use, and to make it very easy for any developer to integrate other components with their application.</p>"},{"location":"basics/dependencies/#what-is-dependency-injection","title":"What is dependency injection?","text":"<p>Dependency injection is a way through which your code declares what dependencies it needs to run, and where your code doesn't explicitly create that dependency when it needs to use it, but rather lets the underlying system/application (in this case, Ergate) automatically create those dependencies for it.</p> <p>Dependency injection is an extremely powerful tool, since it allows you to do things like easily having common shared logic in your code and easily sharing common dependencies across different surfaces of your application, amongst other things; all of it while reducing code repetition.</p>"},{"location":"basics/dependencies/#creating-a-dependency","title":"Creating a dependency","text":"<p>To use dependencies in Ergate, you'll need a function that <code>yield</code>s a dependency. It's important to note that the function must <code>yield</code> one time only. As an example, let's create a dependency that returns a <code>datetime</code> object representing the current time.</p> my_dependency.py<pre><code>from collections.abc import Generator\nfrom datetime import datetime\n\ndef create_current_time() -&gt; Generator[datetime, None, None]:\n    yield datetime.now()\n</code></pre> <p>Info</p> <p>Ergate uses contextmanagers under the hood, so any function that works with them can be used as a dependency.</p>"},{"location":"basics/dependencies/#using-a-dependency","title":"Using a dependency","text":"<p>Now, to use this dependency from within a step, you must first understand the use of an <code>Annotated</code> type. To put it simply, the <code>Annotated</code> type is a way of adding metadata to a type annotation. In this case, the metadata we want to add to our type is that it's a dependency, and that it's generated by a certain callable.</p> <p>To do so, you need to use the <code>Depends</code> class from Ergate, which takes a callable as its first argument. Let's modify the workflow from the previous section to use the dependency we just created.</p> my_workflow.py<pre><code>from datetime import datetime\nfrom typing import Annotated\nfrom ergate import Depends, Workflow\nfrom my_dependency import create_current_time\n\nworkflow = Workflow(unique_name=\"my_first_workflow\")\n\n@workflow.step\ndef step_1(\n    input_value: int,\n    now: Annotated[\n        datetime, # (1)!\n        Depends(create_current_time), # (2)!\n    ],\n) -&gt; int:\n    print(f\"Hello, I am step 1 and I've received {input_value} at {now}\")\n    return input_value + 1\n\n@workflow.step\ndef step_2(input_value: int) -&gt; None:\n    print(f\"Hello, I am step 2 and I've received {input_value}\")\n</code></pre> <ol> <li>The first argument is the actual type of the <code>now</code> argument. This is what type checkers will see it as.</li> <li>Any subsequent arguments are the metadata we want to add to the type. In this case, we're saying that <code>now</code> is a dependency that is generated by the <code>create_current_time</code> callable.</li> </ol>"},{"location":"basics/dependencies/#dependency-arguments","title":"Dependency arguments","text":"<p>Dependencies can take any arguments that workflow steps can take. This means that they can also \"see\" the input values and they can make use of other dependencies too, and same goes for those other subdependencies, and so on to infinity and beyooond.</p> <p>And now, time for another challenge! Can you modify the <code>create_current_time</code> dependency to receive the current timestamp from another dependency and then yield a <code>datetime</code> object created with it. Give it a try and then check our solution below!</p> Solution my_dependency.py<pre><code>from collections.abc import Generator\nfrom datetime import datetime\n\ndef create_current_timestamp() -&gt; Generator[float, None, None]:\n    yield datetime.now().timestamp()\n\ndef create_current_time(\n    timestamp: Annotated[\n        float,\n        Depends(create_current_timestamp),\n    ]\n) -&gt; Generator[datetime, None, None]:\n    yield datetime.fromtimestamp(timestamp)\n</code></pre>"},{"location":"basics/input-values/","title":"Input values","text":"<p>Being able to run workflows that don't depend on external data is cool and all, but most of the time you'll want to run workflows that use some variable input data. Ergate allows you to pass input values when running a workflow.</p>"},{"location":"basics/input-values/#input-values-in-the-first-step","title":"Input values in the first step","text":"<p>The initial input value for a job is stored in the <code>initial_input_value</code> attribute of the <code>Job</code> model. This value is passed to the first step of the workflow when it is run if the step takes any input argument. Following the example from the previous section, let's modify the first step to take an input argument.</p> my_workflow.py<pre><code>from ergate import Workflow\n\nworkflow = Workflow(unique_name=\"my_first_workflow\")\n\n@workflow.step\ndef step_1(input_value: int) -&gt; None:\n    print(f\"Hello, I am step 1 and I've received {input_value}\")\n\n@workflow.step\ndef step_2() -&gt; None:\n    print(\"Hello, I am step 2\")\n</code></pre> <p>If we were processing a job with an initial input value of <code>21</code>, we would now see the following outputs:</p> <ul> <li>\"Hello, I am step 1 and I've received 21\"</li> <li>\"Hello, I am step 2\"</li> </ul>"},{"location":"basics/input-values/#input-values-in-subsequent-steps","title":"Input values in subsequent steps","text":"<p>For any steps other than the first step, the input value they receive will be the return value from the previous step that got executed. This data is stored under the <code>last_return_value</code> attribute of the <code>Job</code> model. Let's modify the workflow so the second step receives some data from the first one.</p> my_workflow.py<pre><code>from ergate import Workflow\n\nworkflow = Workflow(unique_name=\"my_first_workflow\")\n\n@workflow.step\ndef step_1(input_value: int) -&gt; int:\n    print(f\"Hello, I am step 1 and I've received {input_value}\")\n    return input_value + 1\n\n@workflow.step\ndef step_2(input_value: int) -&gt; None:\n    print(f\"Hello, I am step 2 and I've received {input_value}\")\n</code></pre> <p>In this example, if we were processing a job with an initial input value of <code>21</code>, we would now see the following outputs:</p> <ul> <li>\"Hello, I am step 1 and I've received 21\"</li> <li>\"Hello, I am step 2 and I've received 22\"</li> </ul>"},{"location":"basics/input-values/#passing-an-initial-input-value","title":"Passing an initial input value","text":"<p>Passing an initial input value to a job is simple. All you need to do is to provide the <code>initial_input_value</code> argument when creating the <code>Job</code> object.</p> <p>Time for another small challenge. After replacing the demo workflow you have with the one above, can you modify the code from the previous section so that the job is triggered with an initial input value of <code>21</code>? Give it a try and then check our solution below!</p> Solution app.py<pre><code>from ergate import Ergate, Job\nfrom my_queue import MyQueue, queue\nfrom my_state_store import MyStateStore\nfrom my_workflow import workflow\n\napp = Ergate(\n    queue=MyQueue(),\n    state_store=MyStateStore(),\n)\napp.register_workflow(workflow)\n\nif __name__ == \"__main__\":\n    job = Job(workflow_name=\"my_first_workflow\", initial_input_value=21)\n    queue.put(job.model_dump(mode=\"json\"))\n    app.run()\n</code></pre>"},{"location":"basics/jobs-overview/","title":"Jobs overview","text":"<p>In Ergate, a job is an execution of a workflow. It is represented by the <code>Job</code> model, which contains all the necessary information to execute a given workflow.</p> <p>Note</p> <p>Ergate receives jobs through the queue implementation you provide when creating the app. Therefore, how you trigger jobs and create <code>Job</code> objects depends only on your queue implementation. In this guide, we'll show you how to create a <code>Job</code> object and submit it to the queue using the queue implementation from the previous sections.</p>"},{"location":"basics/jobs-overview/#job-attributes","title":"Job attributes","text":"<p>Here is a summary of all the attributes of the <code>Job</code> model.</p> Name Type Required Default User provided id Any N None Y workflow_name str Y N/A Y status JobStatus N JobStatus.QUEUED N current_step int N 0 N steps_completed int N 0 N percent_completed float N 0.0 N initial_input_value Any N None Y last_return_value Any N None N user_context Any N None Y requested_start_time datetime | None N None Y"},{"location":"basics/jobs-overview/#job-status","title":"Job status","text":"<p>A <code>Job</code> can have any of the following statuses:</p> <ul> <li><code>JobStatus.SCHEDULED</code></li> <li><code>JobStatus.QUEUED</code></li> <li><code>JobStatus.RUNNING</code></li> <li><code>JobStatus.COMPLETED</code></li> <li><code>JobStatus.FAILED</code></li> <li><code>JobStatus.ABORTED</code></li> <li><code>JobStatus.PENDING</code></li> <li><code>JobStatus.CANCELLING</code></li> <li><code>JobStatus.CANCELLED</code></li> </ul>"},{"location":"basics/jobs-overview/#triggeringcreating-a-job","title":"Triggering/creating a job","text":"<p>Triggering/creating a job is extremely simple. All you need to do it to submit the necessary data to the queue which your queue implementation will later consume to create a <code>Job</code> object. There is two ways to do this:</p> <ol> <li>Create a <code>Job</code> object on the client, and then dump all of its data into the queue.</li> <li>Submit only the necessary data for a <code>Job</code>'s first run from the client into the queue, and let the queue implementation create the <code>Job</code> object with the default values for all the other fields.</li> </ol> <p>Note</p> <p>Our recommendation is to always use the first approach. The <code>Job</code> model's default values are only valid before the job's first run. After that, the job's metadata (<code>steps_completed</code>, <code>percent_completed</code>, etc...) is updated by Ergate, and it will no longer be valid to use the default values for subsequent runs, which means you will need to submit all of the data through the queue so it can be loaded in the next steps.</p> <p>By using the first approach, not only can you validate data before submitting it to the queue (since the model will raise a <code>ValidationError</code> if it's initialized with invalid values), but you can also ensure that all the job-related data sent through the queue remains consistent; regardless of whether it's the first run or a subsequent run of the job.</p> <p>Throughout this documentation we will only demonstrate the first approach.</p> <p>We now propose you a simple challenge: modify the code from the previous sections so a new job gets submitted to the queue just before starting the app. The job must trigger the workflow named <code>my_first_workflow</code>. Give it a try and then check our solution below!</p> Solution app.py<pre><code>from ergate import Ergate, Job\nfrom my_queue import MyQueue, queue\nfrom my_state_store import MyStateStore\nfrom my_workflow import workflow\n\napp = Ergate(\n    queue=MyQueue(),\n    state_store=MyStateStore(),\n)\napp.register_workflow(workflow)\n\nif __name__ == \"__main__\":\n    job = Job(workflow_name=\"my_first_workflow\") # (1)!\n    queue.put(job.model_dump(mode=\"json\")) # (2)!\n    app.run()\n</code></pre> <ol> <li>Here we're creating the <code>Job</code> object for the workflow named <code>my_first_workflow</code>...</li> <li>...and here we're converting it to JSON and submitting that JSON payload to the queue</li> </ol>"},{"location":"basics/manual-step-ordering/","title":"Using workflow step names for manual ordering","text":"<p>Workflow steps may be manually ordered and redirected by use of <code>GoToEnd</code> and <code>GoToStep</code> exceptions.</p> <p>Workflow ordering can be preempted and redirected by raising the <code>GoToStep</code> exception, passing the workflow step  function along with the optional return value.</p> <p>Workflows may also be advanced directly to completion by raising the <code>GoToEnd</code> exception.</p>"},{"location":"basics/manual-step-ordering/#defining-manual-workflow-order","title":"Defining manual workflow order","text":"<p>The following workflow contains five steps in total, which are executed in a specific order as directed by the  exceptions.</p> my_ordered_workflow.py<pre><code>from ergate import GoToEnd, GoToStep, Workflow\n\nworkflow = Workflow(unique_name=\"my_ordered_workflow\")\n\n@workflow.step\ndef step_1() -&gt; None:\n    print(\"Hello, I am step 1\")\n\n@workflow.step\ndef step_2() -&gt; None:\n    print(\"Hello, I am step 2\")\n    raise GoToStep(step_4)\n\n@workflow.step\ndef step_3() -&gt; None:\n    print(\"Hello, I am step 3\")\n\n@workflow.step\ndef step_4() -&gt; None:\n    print(\"Hello, I am step 4\")\n    raise GoToStep(step_5)\n\n@workflow.step\ndef step_5() -&gt; None:\n    print(\"Hello, I am step 5\")\n    raise GoToEnd()\n</code></pre> <p><code>step_1</code> and <code>step_2</code> execute in normal sequence order.  However, <code>step_2</code> raises the <code>GoToStep</code> exception for <code>step_4</code>, which alters the execution order.  <code>step_3</code> is skipped, and the workflow proceeds directly to <code>step_4</code>.  <code>step_4</code> also  raises <code>GoToStep</code> for <code>step_5</code>, altering the order and proceeding to that function.  Finally, <code>step_5</code> executes, and  then raises <code>GoToEnd</code> to complete the workflow.</p> <p>The resulting order is:</p> <ol> <li><code>step_1</code></li> <li><code>step_2</code></li> <li><code>step_4</code></li> <li><code>step_5</code></li> </ol> <p>Without the <code>GoToStep</code> exception being utilised, this workflow would execute in the source ordering:</p> <ol> <li><code>step_1</code></li> <li><code>step_2</code></li> <li><code>step_3</code></li> <li><code>step_4</code></li> <li><code>step_5</code></li> </ol> <p>This trivial example may seem pointless, as one could readily omit <code>step_3</code> and negate the need for manual ordering  with these exceptions.  However, these features allow for branching of workflows according to arbitrary conditions.</p> <p>Consider the following bifurcated workflow.</p> my_ordered_workflow_2.py<pre><code>from ergate import GoToEnd, GoToStep, Workflow\n\nworkflow = Workflow(unique_name=\"my_ordered_workflow_2\")\n\n@workflow.step\ndef step_1(input_value: str) -&gt; None:\n    print(\"Hello, I am step 1\")\n\n    match input_value:\n        case \"a\":\n            raise GoToStep(step_a2)\n        case \"b\":\n            raise GoToStep(step_b2)\n        case \"c\":\n            raise GoToStep(step_c2)\n        case _:\n            raise GoToStep(step_default2)\n\n@workflow.step\ndef step_default2() -&gt; None:\n    print(\"Hello, I am step default.2\")\n    raise GoToStep(step_4)\n\n@workflow.step\ndef step_a2() -&gt; None:\n    print(\"Hello, I am step a.2\")\n\n@workflow.step\ndef step_a3() -&gt; None:\n    print(\"Hello, I am step a.3\")\n    raise GoToStep(step_4)\n\n@workflow.step\ndef step_b2() -&gt; None:\n    print(\"Hello, I am step b.2\")\n\n@workflow.step\ndef step_b3() -&gt; None:\n    print(\"Hello, I am step b.3\")\n    raise GoToStep(step_4)\n\n@workflow.step\ndef step_c2() -&gt; None:\n    print(\"Hello, I am step c.2\")\n\n@workflow.step\ndef step_c3() -&gt; None:\n    print(\"Hello, I am step c.3\")\n    # Skip remaining steps and complete workflow immediately.\n    raise GoToEnd()\n\n@workflow.step\ndef step_4() -&gt; None:\n    print(\"Hello, I am step 4\")\n</code></pre> <p>In this case, there are four possible paths for the workflow to take, based on the value of <code>input_value</code>:</p> <p>If <code>input_value</code> is <code>a</code>, the workflow path is:</p> <ol> <li><code>step_1</code></li> <li><code>step_a2</code></li> <li><code>step_a3</code></li> <li><code>step_4</code></li> </ol> <p>If <code>input_value</code> is <code>b</code>, the workflow path is:</p> <ol> <li><code>step_1</code></li> <li><code>step_b2</code></li> <li><code>step_b3</code></li> <li><code>step_4</code></li> </ol> <p>If <code>input_value</code> is <code>c</code>, the workflow path is:</p> <ol> <li><code>step_1</code></li> <li><code>step_c2</code></li> <li><code>step_c3</code></li> </ol> <p>with <code>step_4</code> skipped by the <code>GoToEnd</code> raised in <code>step_c3</code>.</p> <p>If <code>input_value</code> is anything else, the workflow path is:</p> <ol> <li><code>step_1</code></li> <li><code>step_default2</code></li> <li><code>step_4</code></li> </ol> <p>Note that the length of the workflows can vary when utilising these exceptions.</p>"},{"location":"basics/manual-step-ordering/#errata","title":"Errata","text":"<ul> <li> <p>Because of how the <code>percent_completed</code> and <code>total_steps</code> values are calculated, utilising manual step ordering with  the related exceptions can cause the percentage and total step calculations to be inaccurate.  It is recommended when  utilising this feature to define the <code>paths</code> each step may follow in the <code>step()</code> decorator, to allow Ergate to better  calculate and predict values for <code>percent_completed</code> and <code>total_steps</code>.  Although they will still not always be fully  accurate, they will be progressive (never reducing back to a lower count of steps completed) and grow in accuracy as  the workflow progresses. </p> </li> <li> <p>Nota bene: it is currently not permitted to use <code>GoToStep</code> to go to a previous step in the workflow.  There is no  technical reason behind this limitation, and it may be added in a future release.</p> </li> </ul>"},{"location":"basics/user-context/","title":"User context","text":"<p>As you may have seen during the jobs overview, the <code>Job</code> object has a <code>user_context</code> attribute that is marked as user-provided, but what is it used for exactly? Let's dig into it!</p> <p>The idea behind <code>user_context</code> is to provide a way for you to store any arbitrary information that needs to be kept permanently and that isn't directly related to the execution of any of the steps (hence it not being useful as a return/input value).</p>"},{"location":"basics/user-context/#passing-user-context","title":"Passing user context","text":"<p>User context is a field in the <code>Job</code> model that can contain any kind of data. To use it, we simply have to create the <code>Job</code> object with the <code>user_context</code> parameter set to the desired value. How you get the data depends on your queue implementation.</p> <p>Using the previous examples in the documentation, we're going to modify how we trigger the job we're queueing just before starting the app, so that its <code>user_context</code> contains information about the user who triggered the job.</p> app.py<pre><code>from ergate import Ergate, Job\nfrom my_queue import MyQueue, queue\nfrom my_state_store import MyStateStore\nfrom my_workflow import workflow\n\napp = Ergate(\n    queue=MyQueue(),\n    state_store=MyStateStore(),\n)\napp.register_workflow(workflow)\n\nif __name__ == \"__main__\":\n    job = Job(\n        workflow_name=\"my_first_workflow\",\n        initial_input_value=21,\n        user_context={\"user\": \"prryplatypus\"},\n    )\n    queue.put(job.model_dump(mode=\"json\"))\n    app.run()\n</code></pre>"},{"location":"basics/user-context/#accessing-user-context","title":"Accessing user context","text":"<p>Accessing user context is very similar to using dependencies, except instead of using <code>Depends(...)</code>, you must use <code>Context()</code> instead.</p> <p>As always, it's challenge time! Can you modify the second step in our workflow so that it prints the name of the user that triggered the job? Give it a try and then check our solution below!</p> Solution my_workflow.py<pre><code>from datetime import datetime\nfrom typing import Annotated, Any\nfrom ergate import Context, Depends, Workflow\nfrom my_dependency import create_current_time\n\nworkflow = Workflow(unique_name=\"my_first_workflow\")\n\n@workflow.step\ndef step_1(\n    input_value: int,\n    now: Annotated[\n        datetime,\n        Depends(create_current_time),\n    ],\n) -&gt; int:\n    print(f\"Hello, I am step 1 and I've received {input_value} at {now}\")\n    return input_value + 1\n\n@workflow.step\ndef step_2(\n    input_value: int,\n    user_context: Annotated[\n        dict[str, Any],\n        Context(),\n    ],\n) -&gt; None:\n    print(\n        f\"Hello, I am step 2 and I've received {input_value} \"\n        f\"thanks to {user_context['user']}\"\n    )\n</code></pre>"},{"location":"basics/workflow-path-hints/","title":"Defining workflow paths","text":"<p>In order to facilitate manually-ordered workflow steps with branching paths, speculative logic was included to predict  the total number of steps for the workflow and thereby calculate the completion percentage.</p> <p>These may be seen as similar to Python type hints, in that they do not directly affect the flow and operation of the  workflow, but provide metadata allowing the engine to better determine information about the workflow operation, viz. the completion percentage and total steps.</p> <p>This logic may be enabled by specifying the <code>paths=</code> kwarg for a given <code>@workflow.step()</code> decorator.</p> <ul> <li>It is not necessary to specify <code>paths</code> for workflow steps which only return a value via <code>return</code>.</li> <li>It is suggested to define <code>paths</code> for steps which utilise the <code>GoToEnd</code> exceptions. </li> <li>It is recommended to define <code>paths</code> for steps which utilise the <code>GoToStep</code> exception, or which have branching logic with multiple potential paths.</li> </ul> <p><code>paths</code> may be freely defined alongside other kwargs in the <code>@workflow.step</code> decorator.</p>"},{"location":"basics/workflow-path-hints/#defining-workflow-paths_1","title":"Defining workflow paths","text":"<p>When defining <code>paths</code>, each potential path should be specified by its Exception.</p> workflow_with_paths.py<pre><code>from ergate import GoToEnd, GoToStep, Workflow\n\nworkflow = Workflow(unique_name=\"workflow_with_paths\")\n\n@workflow.step\ndef step_1() -&gt; int:\n    print(\"Hello, I am step 1\")\n    return 1\n\n@workflow.step(paths=[GoToStepPath(\"step_3\")])\ndef step_2(number: int) -&gt; None:\n    print(\"Hello, I am step 2\")\n    raise GoToStep(step_3, retval=2)\n\n@workflow.step(path=[GoToEndPath()])\ndef step_5() -&gt; None:\n    print(\"Hello, I am step 5\")\n    raise GoToEnd()\n\n@workflow.step\ndef step_3(number: int) -&gt; int:\n    print(\"Hello, I am step 3\")\n    return 3\n\n@workflow.step(paths=[GoToStepPath(\"step_7\"), GoToEndPath()])\ndef step_4(number: int) -&gt; int:\n    print(\"Hello, I am step 4\")\n    if number % 2:\n        raise GoToStep(step_7, retval=4)\n    if number &gt; 6:\n        raise GoToEnd()\n    return 4\n\n@workflow.step\ndef step_6(number: int) -&gt; int:\n    print(\"Hello, I am step 6\")\n    return 6\n\n@workflow.step\ndef step_7(number: int) -&gt; int:\n    print(\"Hello, I am step 7\")\n    return 7\n</code></pre> <p>Calculating the path from <code>step_1</code>, it will calculate <code>('step_1', 'step_2', 'step_3', 'step_4')</code> and then reach a  branching of the paths.  It will then calculate two potential routes for the remainder, resulting in three possible  paths:</p> <ul> <li><code>('step_1', 'step_2', 'step_3', 'step_4')</code></li> <li><code>('step_1', 'step_2', 'step_3', 'step_4', 'step_7')</code></li> <li><code>('step_1', 'step_2', 'step_3', 'step_4', 'step_6', 'step_7')</code></li> </ul> <p>For calculating <code>percent_completed</code> and <code>total_steps</code>, it will use the longest of the potential branches.</p> <p>When <code>step_4</code> is reached and completed, it will then reevaluate the branches to determine which were not taken, and  discard them, leaving only the relevant branch(es) for recalculation and refinement of the <code>percent_completed</code> and  <code>total_steps</code> values.</p> <p>The resulting workflow order from above is:</p> <ol> <li><code>step_1</code></li> <li><code>step_2</code></li> <li><code>step_3</code></li> <li><code>step_4</code> (<code>number == 3</code>, so <code>4</code> is returned)</li> <li><code>step_6</code></li> <li><code>step_7</code></li> </ol> <p>Note that the <code>return</code> path wasn't explicitly specified for <code>step_4</code>, but it is automatically deduced and included from the function's return type hinting.  If however a work step function ever intentionally returns <code>None</code> as a valid  workflow path, but additionally has <code>paths</code> defined for other paths, then <code>NextSteppath()</code> must be manually included in  the list of paths.</p> <p>For example:</p> workflow_with_paths_2.py<pre><code>from ergate import GoToEnd, GoToEndPath, GoToStep, GoToStepPath, Workflow\nfrom datetime import date\n\nworkflow = Workflow(unique_name=\"workflow_with_paths_2\")\n\n@workflow.step(paths=[GoToStepPath(\"step_two\")])\ndef step_one() -&gt; None:\n    print(\"Hello, I am step 1.\")\n    raise GoToStep(step_two)\n\n@workflow.step(paths=[GoToStepPath(\"weekday\"), GoToStepPath(\"saturday\")])\ndef step_two() -&gt; None:\n    print(\"Hello, I am step 2.\")\n\n    today = date.today()\n\n    if today.weekday() &lt; 5:\n        print(\"Today is a weekday.  Do a weekday task.\")\n        raise GoToStep(weekday)\n    if today.weekday() == 5:\n        print(\"Today is Saturday.  Do a Saturday task.\")\n        raise GoToStep(saturday)\n\n    print(\"Today is a Sunday.  Proceed to the next step.\")\n    return None\n\n@workflow.step(paths=[GoToStepPath(\"step_three\")])\ndef sunday() -&gt; None:\n    print(\"Hello, I am Sunday step.\")\n    raise GoToStep(step_three)\n\n@workflow.step(paths=[GoToStepPath(\"step_three\")])\ndef weekday() -&gt; None:\n    print(\"Hello, I am the extra weekday step.\")\n    raise GoToStep(step_three)\n\n@workflow.step(paths=[GoToStepPath(\"step_three\")])\ndef saturday() -&gt; None:\n    print(\"Hello, I am the extra saturday step.\")\n    raise GoToStep(step_three)\n\n@workflow.step\ndef step_three() -&gt; None:\n    print(\"Hello, I am step 3.\")\n</code></pre> <p>In this case, <code>step_two</code> can go to two separate <code>GoToStep</code> destinations, but also can return <code>None</code>.  However, the  natural <code>return</code> path would be ignored due to its <code>None</code> type hinting, since <code>paths</code> were manually specified.</p> <p>To rectify this in this specific instance, one should include <code>NextStepPath()</code> in the list of <code>paths</code>:  <code>@workflow.step(paths=[GoToStepPath(\"weekday\"), GoToStepPath(\"saturday\"), NextStepPath()])</code></p> <p>Steps were organised in such a way to prevent the natural sequencing of <code>step_two</code> or <code>step_three</code> from inadvertently  executing named steps for specific conditions, by placing those conditional steps subsequent to a <code>GoToStep</code> step. </p> <p>Nota bene: the omission of <code>NextStepPath()</code> from the <code>paths</code> would not affect the workflow's operation, and it would  still execute nominally.  This only affects the path calculations for predicting completion percentages and total steps. Further, once the step is executed, branch calculations for future steps (which are recalculated at each step for and  from the current step onwards) would regain their accuracy.</p>"}]}